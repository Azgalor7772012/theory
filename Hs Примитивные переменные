В джаве есть такие примитивные переменные, как:
1) int myInt = 32 - целочисленный тип данные с объемом 32 бита (2 ** 31);
2) short myShort = 3213 - целочисленный тип данные с объемом 16 бит( то есть 2 ** 15 :от -32768 до 32767)
3) long myLong = 12312L - целочисленный тип данные с объемом 64 бита;
Объемом битов говорит о том, от какого до какого значения могут принимать переменные
4) double myDouble = 123.21 - значения дробные 64 бита инфы, могут содержать 14-16 цифр после запятой;
При этом его значения могут быть в диапозоне +- 52 * 2^11;(IEEE 754)
5) float myFloat = 123,21f - дробные значения 32 бита инфы, могут содержать 6-7 цифр после запятой;
При этом его значения могут быть в диапозоне +- 23 * 2^8;(IEEE 754)
Если мы пишем число с точкой, то оно по умолчанию идет double, чтобы показать, что
это float, нужно после числа поставить букву f;
6) char myChar = 'a' - символ. Используется кодировка unicode в диапозоне от 0 до  65536;
Можно задавать через числа ch1 = 67; // код переменной
Можно шестнадцатеричным представлением кода в escape-последовательности char myChar = '\u0054';
7) bool myBool = true -  Он представляет собой только один бит информации, но его размер точно не определен.;
8) byte myByte = 127 - целочисленные значения от -128 до 128

--> Числа можно записывать в следующем формате:
double eps = 5e-3; // means 5 * 10^(-3) = 0.005
double n = 0.01e2; // means 0.01 * 10^2 = 1.0

-->Для операндов double и float оператор /выполняет деление, а не целочисленное деление.
double squaredPi = pi * pi; // 9.86902225
squaredPi / 2 = 4.934511125
При этом :
a = 5
a/2 = 2;
И, чтобы у нас получился ответ не целочисленный, число записанное как float/double должно быть с дробной частью
double d1 = 5 / 4; // 1.0
double d2 = 5.0 / 4; // 1.25

Все переменные выше - примитивные, в случае переноса их в другую переменную, то
там просто копируется ячейка памяти и у нас получается 2 ячейки памяти с одинаковым
значением.

Также есть ссылочные переменные String. Переменная String является классом, а не
объектом. Если просто говорить, то класс - это чертеж машины, а объект это сама
машина

Обычно, для создания строки используется метод String s = "kosta", но этот
метод действует только для строки, обычно объекты для классов создаются так:
String s = new String("kosta") - здесь мы создали объект для класса


// Добавления от hyperskill:

    public static void main(String[] args) {


// Declaring several variables of the same type as a single statement:
        String language = "java", version = "8 or newer";
        int age; // declaration
        age = 35; // initialization
        System.out.println(age);
// --> Вместо определенного типа данных можно написать var и тогда java сама поймет что за тип данных:
        var example = "Define"; // String
    }
}

 В имени переменной могут быть:
 1) Латинский алфавит a..z
 2)Цифры 1..9
 3) Спец.символы $ _
 При этом переменная не может начинаться с цифры и не может быть названа одним подчеркиванием(_), однако двумя(__) может

 -> Переменная типа char записывается в одинарных ковычках '' и соответствует формату
 UTF-16, поэтому каждый его символ соответствует какому-то номеру в этой системе.
 То есть у каждого символа есть уникальный код в формате UTF-16 и он присваевается символу при
 обозначение его как переменной char.
 При этом если мы заходим взять например int от char, то получим число этого символа в юникоде UTF-16:

 int n = 'q'
 sout(q) // 113

 Переменную char можно обозначить:
 1) Символом:
char lowerCaseLetter = 'a';
char upperCaseLetter = 'Q';
2)шестнадцатеричным кодом unicode:
char ch = '\u0040'; // it represents '@'
System.out.println(ch); // @
3)Положительным числом:
char ch = 64;
System.out.println(ch); // @
Число 64просто соответствует шестнадцатеричному коду Unicode '\u0040'.



Бонус Escape последовательности:
\n символ новой строки;
\t символ табуляции;
\r символ возврата каретки;
\\ сам символ обратной косой черты;
\' одинарная кавычка;
\" является двойной кавычкой.

--> От KATA:
Вещественные числа - float и double
Целочисленные - int, short, long, byte
При деление вещественных чисел могут возникнуть такие моменты как:
1) 1.0 / 0.0 ==  + бесконечность
-1.0 / 0.0 ==  - бесконечность
При этом ошибки не выдаст, +- бесконечность входит в вещественные числа.
Все операции с бесконечность поддаются логики:
Например при деление числа на бесконечность получится 0, а при вычитание числа из бесконечности будет
бесконечность
2)0.0 / 0.0 = nan(not a number)
При любых операциях с nan у нас получится nan, при этом nan не равен сам себе.

-->Из-за погрешностей у вещественных чисел нельзя проверять их равенство.
Например если сложить 0.1 + 0.1 + 0.1 десять раз, то мы не получим 1, мы получим число очень близкое
к нему. Поэтому вместо равенства обычно проверяют |a - b| < E - модуль разности двух чисел меньше
какого-то маленького эпсилон.

--> В стандартной библиотеке java.math есть классы, которые нужны на тот случай, если наше число не вмещается
в макс. размер переменной(напр. число больше, чем может вместить long):
BigInteger two = BigInteger.valueOf(); - для целочисленных значений
BigDecimal one = BigDecimal.valueOf(); - для вещественных значений

- При переводе из большей по объему переменной в меньшую:
1)При переводе из int в byte отбрасываются старшие биты числа.
int b = 1024;
byte a = (byte) b - отбросятся лишние биты и, например, из 1024 получится 0
2)При переводе из вещественного числа в целое отбросится дробная часть
int a = (int) b ; Отбрасывается дробная часть b = 3
3)При переводе из long в int(при этом лонг число больше макс значения int) возьмется
максимальное значение интеджера
long a = 12312123123132123;
int b = (int) a; Получается Integer.MAX_VALUE
4)Слишком большое double при приведение к float превращается в бесконечность

-->Автоматическое расширение, если в примере 2 операнда разных типов:
1) Если один из операндов double - приводится к double
1d + 1f -> double
Если операнда double нет, то:
2)Если один из операндов float - приводится к float
1f + 1 -> float
Если операнда float нет, то:
3)Если один из операндов long - приводится к long
1L - 'C' -> long
Если операнда long нет, то:
Примитивы приводятся к int.
То есть даже если мы сложим 2 значения типа byte, то получим int:
byte a = 2;
byte d = 3;
byte c = 3 + 2 - ошибка компиляции
byte c = (byte) 3 + 2 - явное приведение, хотя оба операнда были byte, но неявно
было переведены в int

-->Значения элементов по умолчанию:
1)Примитивы и символы = 0;
2)boolean = false;
3)Ссылочные типы = null;
