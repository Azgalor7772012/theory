-->Мы можем назвать методы одинаково, при их вызове у пользователя будет выбор каким из них пользоваться
если нажать ctl + p(будут видны аргументы метода);

--> Для того, чтобы пользоваться перегрузкой нам нужно менять либо количество аргументов в методе, либо тип
аргументов.
Например нам нужен метод, который возвращает результат от перемножения 2 чисел, но мы хотим, чтобы пользователь
мог ввести как тип int, так и тип double, на этот случай нам и нужна перегрузка:

// Первый метод
int umnozhenie(int a, int b) {
    return a * b;
}
// Второй метод
double umnozhenie(double a, double b) {
    return a * b;
}

// Третий метод
float umnozhenie(float a) {
    return a;
}

При этом перегрузить метод можно либо разным количеством аргументов, либо разным типом. Если мы изменим
тип возвращаемого параметра, то перегрузки не будет. Нужно именно менять аргументы.

Такая перегрузка - форма статического полиморфизма.

Вызываться методы будут одинаково через один метод, но в зависимости от переданных аргументов будут использо-
ваться разные методы. Теоретически мы даже можем сделать так, чтобы методы делали разные(например один метод
будет вычитать из первого числа второе, а другой перемножать их, хотя названия одинаковые), Java понимает
каким методом пользователь хочет пользоваться исходя из количества переданных аргументов или от их типа.

-->Если мы передадим в метод, тип данного которого нет в методе, (например метод принимает примитив long,
а мы ему пишем int, то Java самостоятельно произведен неявное приведение и использует метод, тип аргумента
которого ближайший к переданному типу:
public static void print(long a) {
        System.out.println("long arg: " + a);
    }
print(100), программа выведет:
long arg: 100, хотя мы передали int.
Это нужно помнить так как Java может это делать только в соответсвии с веткой неявного приведения.
Если в методе будет только аргумент типа short, а мы передаем int, то будет ошибка т.к Java не будет
переводить данные в меньший объем памяти, чем исходный самостоятельно. В этом случае нужно будет использовать
явное приведение:
public static void print(short a) {
        System.out.println("short arg: " + a);
    }

    public static void main(String[] args) {
        print((short) 100);  // explicit casting
    }


--> Точно так же работает и с КОНСТРУТОРАМИ КЛАССА! :
class Box {
    int width;
    int length;
    int height;

    Box(int width, int length, int height) {
        this.width = width;
        this.length = length;
        this.height = height;
    }

    Box(double size) {
       this.width = size;
       this.length = size;
       this.height = size;
    }
}

Так же мы можем вызывать один конструктор с помощью другого конструктора при использовании ключевого слова this:
public class Robot {
    String name;
    String model;
    int lifetime;

    public Robot() {
        this.name = "Anonymous";
        this.model = "Unknown";
    }
    !!Конструктор, который вызываем другой конструктор.
    public Robot(String name, String model) {
        this(name, model, 20);  // Здесь мы передаем конструктору с данным типом и количеством аргументов наши параметры
        и внутри этого конструктора вызываем другой. При этом слово this используется как метод.
    }

    public Robot(String name, String model, int lifetime) {
        this.name = name;
        this.model = model;
        this.lifetime = lifetime;
    }
}