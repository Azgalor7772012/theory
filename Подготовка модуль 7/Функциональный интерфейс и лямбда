Функциональный интерфейс - интерфейс, который содержит только 1 абстрактный метод, default и статических
методов может быть сколько угодно, но абстрактный должен быть один.
Сделано это для возможности его реализации с помощью анонимного класса и лямбда выражений

1) Реализовать отдельный класс - реализовываем целый отдельный класс и у него переопределяем метод.
Очень громоздко и если метод не будет пере использоваться, то ни к чему.

2)Анонимный класс - передаем аргументом новый экземепляр интерфейса, тогда Java создаст анонимный класс,
в котором предложит переопределить единственный метод

info.testStudents(students, new StudentChecks() {
            @Override
            public boolean check(Student s) {
                return s.age > 30;
            }
        });

3)Лямбда выражения - нет необходимости создавать анонимный класс, сама реализация метода идет 2 аргументом
При этом "->" разделяет параметры метода и тело метода.
В лямбда выражении справа от оператора стрелка находится тело метода, которое было бы у метода, который
имплементировал интерфейс и реализовал его.

-3.1 Длинный способ - указываем переменную метода и после в {} тело метода:
info.testStudents(students, (Student s) -> {return s.age > 30;});

-3.2 Короткий способ - указываем переменную и что с этой переменной делаем:
info.testStudents(students, p -> p.sex =='f');

-3.3 Смешанный способ - слева и справа можно миксовать полный/неполный вариант написания
info.testStudents(students, p -> {return p.avgGrade < 8.3;});
info.testStudents(students, (Student s) -> s.avgGrade > 9 && s.sex ==  'f');

Правила:
1)Если используется полный вариант написания для части лямбда выражения справа от стрелки, то нужно
использовать return + ;

2)Левая часть лямбда выражения может быть написана в краткой форме, если метод интерфейса принимает
только 1 параметр. Если метод принимает более одного параметра, то нужно писать длинную версию
info.testStudents(students, (Student s, int age) -> {return s.age > 30;}); или короче
info.testStudents(students, (s, age) -> {return s.age > 30;});

3)Если мы хотим в левой части лямбда выражения явно объявить тип переменной, то также левую часть нужно
брать в скобки
info.testStudents(students, (Student s) ->  s.age > 30);

4)Если в правой части используется больше 1 действия, то нужно использовать полную версию:
info.testStudents(students, p -> {
       sout("Hello");
       return p.avgGrade < 8.3;
       });

5)Если метод в интерфейсе не принимает аргументов, то нужно вместо переменной ставить () :
info.testStudents(students, () -> {return 30;});

6)Лямбда выражение можно вынести отдельной переменной с типом интерфейса
StudentCheck sc = p -> {return p.avgGrade < 8.3;}
Теперь можно вызвать метод с переменной sc вместо лямбда выражения
info.testStudents(students, sc);

7)В лямбда выражениях можно использовать переменные объявленные вне лямбда выражений в методе в том случае если
они final, либо если они объявлены один раз и нигде по ходу программы не меняют свое значение(Effectively final)
+ Можно использовать переменные класса, они могут меняться
 int i = 0;
        info.testStudents(students, st -> {
            System.out.println(i); //Выводим несколько раз т.к в самом методе сделан цикл
            return st.sex == 'f';
        });


4)Функциональный интерфейс можно инстанцировать с помощью ссылки на метод