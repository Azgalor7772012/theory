->Полиморфизм - способность метода с одним названием обрабатывать разные типы данных.
В Java есть 2 вида полиморфизма:
1)Статический(во время компиляции) - достигается за счет перегрузки методов
2)Динамический(время выполнения) - основан на наследовании и переопределении методов

-> К Динамическому полиморфизму относится полиморфизм подтипов, когда мы можем вызывать объект
дочернего класса с ссылкой на родительский класс. При этом методы будут работать как в дочернем
классе, но в нем будут отсутствовать поля и методы, которых нет в родительском классе.
Также сюда относится переопределение методов в дочернем классе с/без аннотации @Override

Одно из проявлений полиморфизма - способность обращаться к объекту через переменную родительского типа:

class Dog extends Animal {

}
public static void main(String[] args) {
    Animal dog = new Dog(); // Объект класса Dog, а переменная типа Animal
}
При этом при таком создании, мы не имеем доступ к методам и полям класса Dog. У нас фактически объект имеет
только поля и методы класса Animal, а своих у него нет.
А когда мы создаем новый объект своего типа:
    Dog dog = new Dog();
Мы имеем все методы и поля данного класса + класса родителя.

-->Позднее связывание:
Это переопределение методов родительского класса в дочернем, при этом при вызове объекта дочернего класса
с типом родительского.

class Animal {
    public void voice() {
        System.out.println("Hi");
    }
}

class Dog extends Animal {
    @Override
    public void voice() {
            System.out.println("I am Dog");
        }
}
Что выведется при следующей записи?

Animal dog = new Dog();
dog.voice(); ???
Здесь, не смотря на то, что у нас есть только методы родительского класса, при вызове объекта дочернего,
исполняются его методы, просто его методы ограничены только методами родительского класса, поэтому мы
увидим "I am Dog";

--> Еще одной фишкой полиморфизма считается возможность вызывать дочерние классы в методе в качестве аргумента.
Класс Animal является родительским для классов Dog и Cat, тогда:
Class Animal{
    public static void eat(){
        sout("am eating");
    }
}
public static void voice(Animal animal) {
    Animal.eat();
}
Мы можем вызвать в качестве аргумента этого метода все дочерние классы класса Animal:
psvm(String[] args) {
    Animal animal = new Animal();
    Dog dog = new Dog();
    Cat cat = new Cat();
    voice(animal);
    voice(dog);
    voice(cat); // Все варианты верные и все методы внутри функции будут вызывать методы, присущие конкретному
объекту класса. При этом если в дочернем классе родительский метод переопределен, то вызовется именно
переопределенный метод

!ЭТО ДЕЛАЕТ КОД МЕНЬШЕ И С ВОЗМОЖНОСТЬЮ МНОГОРАЗОВОГО ИСПОЛЬЗОВАНИЯ
}

-->Переопределение метода должно соблюдать следующие условия:
1)Количество и тип аргументов должен быть такой же, как и у класса родителя.
2)Возвращаемый тип должен быть такой же, как у класса родителя или тип наследника типа родителя
3)Модификатор доступа должен быть такой же, как у класса родителя либо более открытый

--> Перегрузка метода должна соблюдать следующие условия:
1)То же название метода, но разные типы аргументов либо разное их количество
2)Возвращаемый тип можно менять, но если поменять только его, то перегрузкой это считаться не будет