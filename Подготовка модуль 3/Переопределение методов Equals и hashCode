Переопределение метода equals() :

-По умолчанию метод equals сравнивает 2 объекта, если они равны - возвращает true, иначе - false;
Но по умолчанию оно может сравнивать неправильно, например нам нужно сравнивать поля нашего класса,
если они равны - true, иначе - false, тогда нам нужно переопределить метод под нас.

-При переопределение метода equals нужно учитывать следующие правила:
1)Рефлексивность - объект должен быть равен самому себе:
a.equals(a) - Всегда true
2)Симметричность - не важно в каком порядке мы сравниваем объекты
a.equals(b) == b.equals(a)
3)Транзитивность - если a.equals(b) = true && b.equals(c) == true, то
a.equals(c) так же true;
4)Согласованность - повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор,
пока какое-либо значение свойств объекта не будет изменено
a.equals(b) == true
a.equals(b) == true и т.д пока что-то не изменится в объектах
5)Сравнение с null должно возвращать false вместо NullPointerException

-Порядок переопределения метода:
1)Сравниваем на то, если поданный объект равен сравниваемому
    if(ComplexNumber == someObject) {
        return true;
    }
2)Сравниваем на то, чтобы поданный объект не равнялся null и был тем же классом(подклассом), что и
изначальный объект для сравнения
    if (someObject == null || ComplexNumber.getClass() != someObject.getClass()) {
        return false;
    }
3)Сравниваем необходимые нам поля у классов, не забывая проверять на null, при этом сравниваемый класс
нужно привести явным приведением к исходному
    ComplexNumber obj = (ComplexNumber) someObject;
    return this.someField != null && this.someField.equals(someObject.getSomeField);

-> По итогу имеем следующее:
    @Override
    public boolean equals(Object o) { //Здесь класс Object т.к если поставить другой, то его компилятор может не принять
1.      if (this == o ) {
           return true;
        }
2.      if (o == null || this.getClass() != o.getClass()) {
            return false
        }
3.      return this.someField != null && this.someFiled.equals(o.getSomeField());
        // Если не проверить this.someField на null, то получим NPE, а так мы потенциально можем запихнуть
        только o.getSomeField() в скобки и даже если там null, то получим False вместо NPE
    }

-->hashCode:
Тип возвращаемого аргумента hashCode - int -> public int hashCode();
Здесь мы можем брать значение полей, либо как-то играться с полями, чтобы у объекта был свой хэшкод
У строки,например можно просто взять хэшкод.
После желательно проделать манимуляцию типа:

    String a = "mom";
    String b = "mom"; // У этих двух строк один и тот же хэшкод;
    public int hashCode() {
        return a.hashCode() - b.hashCode();
        //Получаем индивидуальный хэшкод объекта при этих полях. При этом даже если поменять местами
        a и b хэшкод будет разный, т.к будет разный знак.
    }

-->Контракт между equals() и hashCode():
1)Если изменил equals - меняй и хэшкод.
2)Если хэшкоды равны, то это еще не значит, что объекты равны. Но если они разные, то объекты точно разные
3)Если объекты равны по equals, то они точно равны по хэшкоду.
Если рассматривать HashSet, то там мы храним элементы по корзинам, каждая корзина отвечает за свой
хэшкод, после того, как мы попали в корзину, то мы с помощью equals ищем нужный нам элемент. Если
переназначать только один equals/hashcode, то элемент никогда не найдется