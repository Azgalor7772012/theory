--> Аннотация — это специальный инструмент Java, предоставляющий информацию о программе.
С помощью аннотаций можно поменять классы, методы, поля, переменные и другие части программы.

Пример аннотации:
@Override
public void printName() {
    System.out.println(this.name);
}
Также можно пометить класс/метод/поле/и т. д. двумя или более аннотациями.


--> В Java есть несколько встроенных аннотаций. Если нужно использовать другие аннотации, необходимо
будет импортировать библиотеки или  использовать фреймворки или даже создать свои собственные аннотации.

--> 3 основные встроенные аннотации:
1) @Deprecated— это простая аннотация, которая означает, что помеченный метод (или класс, поле и т. д.)
устарел, то есть больше не должен использоваться. Эта аннотация вызывает предупреждение компиляции, если
код используется.

@Deprecated
public void oldMethod() {
    System.out.println("Hello!");
}

2) @SuppressWarnings дает команду компилятору отключить некоторые предупреждения во время компиляции.
Мы указываете в параметрах, какие предупреждения мы не хотим видеть, например:

  @SuppressWarnings("unused")
  public void printHello() {
      System.out.println("Hello!");
  }

Предположим мы создали метод, но пока что ни разу не использовали его в нашей программе, тогда компилятор
покажет мол вы ни разу не использовали этот метод. Чтобы такого не было используется эта аннотация

3) @Override отмечает метод, который переопределяет метод суперкласса. Эта аннотация может применяться
только к методам.

--> Также есть 2 часто используемые аннотации из внешних источников:
1)@NutNull - указывает на то, что значение переменной не должно быть null
@NotNull
      private String login;
2)@Range - указывает, что значение переменной всегда должно быть в заданном ренже
@Range(min = 1, max = 100)
      private int level = 1;

--> Аргументы аннотаций - аргументы аннотаций, это значений, пишущиеся в скобках у аннотаций, например
"unused" у @SuppressWarnings.

1)Аргументы @Deprecated:
Аргументы since(String), forRemoval(boolean, по умолчанию false)
@Deprecated(since = "5.3", forRemoval = true)
public void printHello() {
    System.out.println("Hello!");
Приведенный выше пример означает, что printHelloметод устарел, начиная с версии 5.3 нашей библиотеки,
и он будет удален в следующем выпуске.
}
2)Аргументы @SuppressWarnings:
@SuppressWarnings({"unused", "deprecation"}) - говорит комплиятору подавлять предупреждения о unused и
устаревших классах, методах, полях, переменных

-->Аннотация @override:
Переопределение метода класса-родителя с той же сигнатурой и возвращаемым параметром у дочернего
класса
Правила переопределения:
1)Метод должен иметь то же имя, что и в суперклассе;
2)Аргументы должны быть точно такими же, как в методе суперкласса;
3)Возвращаемый тип данных должен быть того же типа или подтипом возвращаемого типа, который объявлен
в методе суперкласса;
4)У переопределяемого метода уровень доступа должен быть такой же или более открытым, чем у метода класса родителя
5)Private метод нельзя переопределить, поскольку он не наследуется подклассами;
6)Если суперкласс и его подкласс находятся в одном пакете, то частные методы пакета могут быть переопределены;
7)Cтатические методы не могут быть переопределены.

Тезисно при переопределении метода:
1. У методов должно быть одно название
2. Одни аргументы и один тип аргументов
3. Возвращаемый тип данных должен быть таким ж
3. Доступность у метода, который у дочернего класса больше или такая же
4. Private и Статические методы не переопределяются

Если нужно запретить переопределение метода, то нужно объявить его с помощью слова final

При этом если класс унаследуется от класса, который унаследовался от другого класса. И во втором классе
был переопределен метод самого главного родительского класса, то 3 класс, который наследуется в последнюю
очередь будет иметь переопределенный метод:
class A {

    public void print() {
        System.out.println("A");
    }
}

class B extends A {

    @Override
    public void print() {
        System.out.println("B");
    }
}

class C extends B { }

C c = new C();
c.print(); // B